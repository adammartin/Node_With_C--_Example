// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoEqModel.proto

#ifndef PROTOBUF_ProtoEqModel_2eproto__INCLUDED
#define PROTOBUF_ProtoEqModel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace EqModel {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoEqModel_2eproto();
void protobuf_AssignDesc_ProtoEqModel_2eproto();
void protobuf_ShutdownFile_ProtoEqModel_2eproto();

class Offset;
class ProtoConnection;
class ProtoConnectionRelationship;
class ProtoRank;
class ProtoWorkingElement;
class ProtoWorkingData;
class ProtoWorkingState;
class ProtoWorkingFunction;
class ProtoFrame;
class ProtoEquipmentModel;

enum EFrameType {
  FT_UNDEFINED = 0,
  FT_MACHINE = 1,
  FT_IMPLEMENT = 2
};
bool EFrameType_IsValid(int value);
const EFrameType EFrameType_MIN = FT_UNDEFINED;
const EFrameType EFrameType_MAX = FT_IMPLEMENT;
const int EFrameType_ARRAYSIZE = EFrameType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFrameType_descriptor();
inline const ::std::string& EFrameType_Name(EFrameType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFrameType_descriptor(), value);
}
inline bool EFrameType_Parse(
    const ::std::string& name, EFrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFrameType>(
    EFrameType_descriptor(), name, value);
}
enum EWorkingFunctionType {
  WF_UNDEFINED = 0,
  WF_LOCOMOTION = 1,
  WF_HARVEST = 2,
  WF_PRODUCT_APPLICATION = 3,
  WF_PLANTING = 4,
  WF_TILLING = 5
};
bool EWorkingFunctionType_IsValid(int value);
const EWorkingFunctionType EWorkingFunctionType_MIN = WF_UNDEFINED;
const EWorkingFunctionType EWorkingFunctionType_MAX = WF_TILLING;
const int EWorkingFunctionType_ARRAYSIZE = EWorkingFunctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EWorkingFunctionType_descriptor();
inline const ::std::string& EWorkingFunctionType_Name(EWorkingFunctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EWorkingFunctionType_descriptor(), value);
}
inline bool EWorkingFunctionType_Parse(
    const ::std::string& name, EWorkingFunctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EWorkingFunctionType>(
    EWorkingFunctionType_descriptor(), name, value);
}
enum EViewType {
  VT_UNDEFINED = 0,
  VT_MASTER = 1,
  VT_METER = 2,
  VT_SECTION = 3,
  VT_ROW = 4
};
bool EViewType_IsValid(int value);
const EViewType EViewType_MIN = VT_UNDEFINED;
const EViewType EViewType_MAX = VT_ROW;
const int EViewType_ARRAYSIZE = EViewType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EViewType_descriptor();
inline const ::std::string& EViewType_Name(EViewType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EViewType_descriptor(), value);
}
inline bool EViewType_Parse(
    const ::std::string& name, EViewType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EViewType>(
    EViewType_descriptor(), name, value);
}
enum EAxleLocation {
  AL_UNDEFINED = 0,
  AL_FRONT_AXLE = 1,
  AL_REAR_AXLE = 2
};
bool EAxleLocation_IsValid(int value);
const EAxleLocation EAxleLocation_MIN = AL_UNDEFINED;
const EAxleLocation EAxleLocation_MAX = AL_REAR_AXLE;
const int EAxleLocation_ARRAYSIZE = EAxleLocation_MAX + 1;

const ::google::protobuf::EnumDescriptor* EAxleLocation_descriptor();
inline const ::std::string& EAxleLocation_Name(EAxleLocation value) {
  return ::google::protobuf::internal::NameOfEnum(
    EAxleLocation_descriptor(), value);
}
inline bool EAxleLocation_Parse(
    const ::std::string& name, EAxleLocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EAxleLocation>(
    EAxleLocation_descriptor(), name, value);
}
enum EEquipmentType {
  ET_UNDEFINED = 0,
  ET_TRACTOR = 1,
  ET_COMBINE = 2,
  ET_SPRAYER = 3,
  ET_SPREADER = 4,
  ET_SEEDER = 5,
  ET_OTHER = 6
};
bool EEquipmentType_IsValid(int value);
const EEquipmentType EEquipmentType_MIN = ET_UNDEFINED;
const EEquipmentType EEquipmentType_MAX = ET_OTHER;
const int EEquipmentType_ARRAYSIZE = EEquipmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEquipmentType_descriptor();
inline const ::std::string& EEquipmentType_Name(EEquipmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEquipmentType_descriptor(), value);
}
inline bool EEquipmentType_Parse(
    const ::std::string& name, EEquipmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEquipmentType>(
    EEquipmentType_descriptor(), name, value);
}
enum ERecordingSource {
  RS_UNDEFINED = 0,
  RS_MANUAL = 1,
  RS_AUTO = 2,
  RS_PTO = 3,
  RS_ACCUDEPTH = 4,
  RS_HITCH = 5,
  RS_SCV1 = 6,
  RS_SCV2 = 7,
  RS_SCV3 = 8,
  RS_SCV4 = 9,
  RS_SCV5 = 10,
  RS_SCV6 = 11,
  RS_SCV7 = 12,
  RS_SCV8 = 13,
  RS_SCV9 = 14,
  RS_SCV10 = 15,
  RS_SCV11 = 16,
  RS_SCV12 = 17,
  RS_SCV13 = 18,
  RS_IMPLEMENT_SWITCH = 19
};
bool ERecordingSource_IsValid(int value);
const ERecordingSource ERecordingSource_MIN = RS_UNDEFINED;
const ERecordingSource ERecordingSource_MAX = RS_IMPLEMENT_SWITCH;
const int ERecordingSource_ARRAYSIZE = ERecordingSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERecordingSource_descriptor();
inline const ::std::string& ERecordingSource_Name(ERecordingSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERecordingSource_descriptor(), value);
}
inline bool ERecordingSource_Parse(
    const ::std::string& name, ERecordingSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERecordingSource>(
    ERecordingSource_descriptor(), name, value);
}
enum EConnectionPosition {
  CP_UNDEFINED = 0,
  CP_FRONT = 1,
  CP_REAR = 2
};
bool EConnectionPosition_IsValid(int value);
const EConnectionPosition EConnectionPosition_MIN = CP_UNDEFINED;
const EConnectionPosition EConnectionPosition_MAX = CP_REAR;
const int EConnectionPosition_ARRAYSIZE = EConnectionPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* EConnectionPosition_descriptor();
inline const ::std::string& EConnectionPosition_Name(EConnectionPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    EConnectionPosition_descriptor(), value);
}
inline bool EConnectionPosition_Parse(
    const ::std::string& name, EConnectionPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EConnectionPosition>(
    EConnectionPosition_descriptor(), name, value);
}
enum EHitchType {
  HT_UNDEFINED = 0,
  HT_TRACTOR_DRAWBAR = 1,
  HT_THREE_POINT_HITCH_SEMI_MOUNTED = 2,
  HT_THREE_POINT_HITCH_MOUNTED = 3,
  HT_HITCH_HOOK = 4,
  HT_CLEVIS_COUPLING = 5,
  HT_PITON_TYPE_COUPLING = 6,
  HT_CUNA_HITCH = 7,
  HT_BALL_HITCH = 8,
  HT_THREE_POINT_HITCH_MOUNTED_FRONT = 9
};
bool EHitchType_IsValid(int value);
const EHitchType EHitchType_MIN = HT_UNDEFINED;
const EHitchType EHitchType_MAX = HT_THREE_POINT_HITCH_MOUNTED_FRONT;
const int EHitchType_ARRAYSIZE = EHitchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHitchType_descriptor();
inline const ::std::string& EHitchType_Name(EHitchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHitchType_descriptor(), value);
}
inline bool EHitchType_Parse(
    const ::std::string& name, EHitchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHitchType>(
    EHitchType_descriptor(), name, value);
}
// ===================================================================

class Offset : public ::google::protobuf::Message {
 public:
  Offset();
  virtual ~Offset();

  Offset(const Offset& from);

  inline Offset& operator=(const Offset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offset& default_instance();

  void Swap(Offset* other);

  // implements Message ----------------------------------------------

  Offset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offset& from);
  void MergeFrom(const Offset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double Inline = 1;
  inline bool has_inline_() const;
  inline void clear_inline_();
  static const int kInlineFieldNumber = 1;
  inline double inline_() const;
  inline void set_inline_(double value);

  // optional double Lateral = 2;
  inline bool has_lateral() const;
  inline void clear_lateral();
  static const int kLateralFieldNumber = 2;
  inline double lateral() const;
  inline void set_lateral(double value);

  // optional double Height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline double height() const;
  inline void set_height(double value);

  // @@protoc_insertion_point(class_scope:EqModel.Offset)
 private:
  inline void set_has_inline_();
  inline void clear_has_inline_();
  inline void set_has_lateral();
  inline void clear_has_lateral();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double inline__;
  double lateral_;
  double height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static Offset* default_instance_;
};
// -------------------------------------------------------------------

class ProtoConnection : public ::google::protobuf::Message {
 public:
  ProtoConnection();
  virtual ~ProtoConnection();

  ProtoConnection(const ProtoConnection& from);

  inline ProtoConnection& operator=(const ProtoConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoConnection& default_instance();

  void Swap(ProtoConnection* other);

  // implements Message ----------------------------------------------

  ProtoConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoConnection& from);
  void MergeFrom(const ProtoConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .EqModel.Offset ConnectionOffset = 1;
  inline bool has_connectionoffset() const;
  inline void clear_connectionoffset();
  static const int kConnectionOffsetFieldNumber = 1;
  inline const ::EqModel::Offset& connectionoffset() const;
  inline ::EqModel::Offset* mutable_connectionoffset();
  inline ::EqModel::Offset* release_connectionoffset();
  inline void set_allocated_connectionoffset(::EqModel::Offset* connectionoffset);

  // optional .EqModel.EConnectionPosition ConnectionPosition = 2 [default = CP_UNDEFINED];
  inline bool has_connectionposition() const;
  inline void clear_connectionposition();
  static const int kConnectionPositionFieldNumber = 2;
  inline ::EqModel::EConnectionPosition connectionposition() const;
  inline void set_connectionposition(::EqModel::EConnectionPosition value);

  // optional .EqModel.EHitchType HitchType = 3 [default = HT_UNDEFINED];
  inline bool has_hitchtype() const;
  inline void clear_hitchtype();
  static const int kHitchTypeFieldNumber = 3;
  inline ::EqModel::EHitchType hitchtype() const;
  inline void set_hitchtype(::EqModel::EHitchType value);

  // @@protoc_insertion_point(class_scope:EqModel.ProtoConnection)
 private:
  inline void set_has_connectionoffset();
  inline void clear_has_connectionoffset();
  inline void set_has_connectionposition();
  inline void clear_has_connectionposition();
  inline void set_has_hitchtype();
  inline void clear_has_hitchtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::EqModel::Offset* connectionoffset_;
  int connectionposition_;
  int hitchtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoConnection* default_instance_;
};
// -------------------------------------------------------------------

class ProtoConnectionRelationship : public ::google::protobuf::Message {
 public:
  ProtoConnectionRelationship();
  virtual ~ProtoConnectionRelationship();

  ProtoConnectionRelationship(const ProtoConnectionRelationship& from);

  inline ProtoConnectionRelationship& operator=(const ProtoConnectionRelationship& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoConnectionRelationship& default_instance();

  void Swap(ProtoConnectionRelationship* other);

  // implements Message ----------------------------------------------

  ProtoConnectionRelationship* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoConnectionRelationship& from);
  void MergeFrom(const ProtoConnectionRelationship& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 SourceFrameIndex = 1;
  inline bool has_sourceframeindex() const;
  inline void clear_sourceframeindex();
  static const int kSourceFrameIndexFieldNumber = 1;
  inline ::google::protobuf::int32 sourceframeindex() const;
  inline void set_sourceframeindex(::google::protobuf::int32 value);

  // optional int32 SourceConnectionIndex = 2;
  inline bool has_sourceconnectionindex() const;
  inline void clear_sourceconnectionindex();
  static const int kSourceConnectionIndexFieldNumber = 2;
  inline ::google::protobuf::int32 sourceconnectionindex() const;
  inline void set_sourceconnectionindex(::google::protobuf::int32 value);

  // optional int32 TargetFrameIndex = 3;
  inline bool has_targetframeindex() const;
  inline void clear_targetframeindex();
  static const int kTargetFrameIndexFieldNumber = 3;
  inline ::google::protobuf::int32 targetframeindex() const;
  inline void set_targetframeindex(::google::protobuf::int32 value);

  // optional int32 TargetConnectionIndex = 4;
  inline bool has_targetconnectionindex() const;
  inline void clear_targetconnectionindex();
  static const int kTargetConnectionIndexFieldNumber = 4;
  inline ::google::protobuf::int32 targetconnectionindex() const;
  inline void set_targetconnectionindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EqModel.ProtoConnectionRelationship)
 private:
  inline void set_has_sourceframeindex();
  inline void clear_has_sourceframeindex();
  inline void set_has_sourceconnectionindex();
  inline void clear_has_sourceconnectionindex();
  inline void set_has_targetframeindex();
  inline void clear_has_targetframeindex();
  inline void set_has_targetconnectionindex();
  inline void clear_has_targetconnectionindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 sourceframeindex_;
  ::google::protobuf::int32 sourceconnectionindex_;
  ::google::protobuf::int32 targetframeindex_;
  ::google::protobuf::int32 targetconnectionindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoConnectionRelationship* default_instance_;
};
// -------------------------------------------------------------------

class ProtoRank : public ::google::protobuf::Message {
 public:
  ProtoRank();
  virtual ~ProtoRank();

  ProtoRank(const ProtoRank& from);

  inline ProtoRank& operator=(const ProtoRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoRank& default_instance();

  void Swap(ProtoRank* other);

  // implements Message ----------------------------------------------

  ProtoRank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoRank& from);
  void MergeFrom(const ProtoRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RankID = 1;
  inline bool has_rankid() const;
  inline void clear_rankid();
  static const int kRankIDFieldNumber = 1;
  inline ::google::protobuf::uint32 rankid() const;
  inline void set_rankid(::google::protobuf::uint32 value);

  // required double Width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline double width() const;
  inline void set_width(double value);

  // optional .EqModel.Offset LocalCenter = 3;
  inline bool has_localcenter() const;
  inline void clear_localcenter();
  static const int kLocalCenterFieldNumber = 3;
  inline const ::EqModel::Offset& localcenter() const;
  inline ::EqModel::Offset* mutable_localcenter();
  inline ::EqModel::Offset* release_localcenter();
  inline void set_allocated_localcenter(::EqModel::Offset* localcenter);

  // repeated sint32 ChildElementIndex = 4;
  inline int childelementindex_size() const;
  inline void clear_childelementindex();
  static const int kChildElementIndexFieldNumber = 4;
  inline ::google::protobuf::int32 childelementindex(int index) const;
  inline void set_childelementindex(int index, ::google::protobuf::int32 value);
  inline void add_childelementindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      childelementindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_childelementindex();

  // @@protoc_insertion_point(class_scope:EqModel.ProtoRank)
 private:
  inline void set_has_rankid();
  inline void clear_has_rankid();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_localcenter();
  inline void clear_has_localcenter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double width_;
  ::EqModel::Offset* localcenter_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > childelementindex_;
  ::google::protobuf::uint32 rankid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoRank* default_instance_;
};
// -------------------------------------------------------------------

class ProtoWorkingElement : public ::google::protobuf::Message {
 public:
  ProtoWorkingElement();
  virtual ~ProtoWorkingElement();

  ProtoWorkingElement(const ProtoWorkingElement& from);

  inline ProtoWorkingElement& operator=(const ProtoWorkingElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoWorkingElement& default_instance();

  void Swap(ProtoWorkingElement* other);

  // implements Message ----------------------------------------------

  ProtoWorkingElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoWorkingElement& from);
  void MergeFrom(const ProtoWorkingElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double Width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline double width() const;
  inline void set_width(double value);

  // optional .EqModel.Offset CenterOffset = 2;
  inline bool has_centeroffset() const;
  inline void clear_centeroffset();
  static const int kCenterOffsetFieldNumber = 2;
  inline const ::EqModel::Offset& centeroffset() const;
  inline ::EqModel::Offset* mutable_centeroffset();
  inline ::EqModel::Offset* release_centeroffset();
  inline void set_allocated_centeroffset(::EqModel::Offset* centeroffset);

  // optional uint32 ElementID = 3;
  inline bool has_elementid() const;
  inline void clear_elementid();
  static const int kElementIDFieldNumber = 3;
  inline ::google::protobuf::uint32 elementid() const;
  inline void set_elementid(::google::protobuf::uint32 value);

  // optional .EqModel.EViewType ViewType = 4 [default = VT_UNDEFINED];
  inline bool has_viewtype() const;
  inline void clear_viewtype();
  static const int kViewTypeFieldNumber = 4;
  inline ::EqModel::EViewType viewtype() const;
  inline void set_viewtype(::EqModel::EViewType value);

  // optional double Left = 5;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 5;
  inline double left() const;
  inline void set_left(double value);

  // optional double Right = 6;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 6;
  inline double right() const;
  inline void set_right(double value);

  // optional double Size = 7;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 7;
  inline double size() const;
  inline void set_size(double value);

  // optional sint32 ParentElementIndex = 8;
  inline bool has_parentelementindex() const;
  inline void clear_parentelementindex();
  static const int kParentElementIndexFieldNumber = 8;
  inline ::google::protobuf::int32 parentelementindex() const;
  inline void set_parentelementindex(::google::protobuf::int32 value);

  // repeated sint32 WorkingStateIndex = 9;
  inline int workingstateindex_size() const;
  inline void clear_workingstateindex();
  static const int kWorkingStateIndexFieldNumber = 9;
  inline ::google::protobuf::int32 workingstateindex(int index) const;
  inline void set_workingstateindex(int index, ::google::protobuf::int32 value);
  inline void add_workingstateindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      workingstateindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_workingstateindex();

  // repeated sint32 ChildElementIndex = 10;
  inline int childelementindex_size() const;
  inline void clear_childelementindex();
  static const int kChildElementIndexFieldNumber = 10;
  inline ::google::protobuf::int32 childelementindex(int index) const;
  inline void set_childelementindex(int index, ::google::protobuf::int32 value);
  inline void add_childelementindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      childelementindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_childelementindex();

  // repeated sint32 WorkingDataIndex = 11;
  inline int workingdataindex_size() const;
  inline void clear_workingdataindex();
  static const int kWorkingDataIndexFieldNumber = 11;
  inline ::google::protobuf::int32 workingdataindex(int index) const;
  inline void set_workingdataindex(int index, ::google::protobuf::int32 value);
  inline void add_workingdataindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      workingdataindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_workingdataindex();

  // @@protoc_insertion_point(class_scope:EqModel.ProtoWorkingElement)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_centeroffset();
  inline void clear_has_centeroffset();
  inline void set_has_elementid();
  inline void clear_has_elementid();
  inline void set_has_viewtype();
  inline void clear_has_viewtype();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_parentelementindex();
  inline void clear_has_parentelementindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double width_;
  ::EqModel::Offset* centeroffset_;
  ::google::protobuf::uint32 elementid_;
  int viewtype_;
  double left_;
  double right_;
  double size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > workingstateindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > childelementindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > workingdataindex_;
  ::google::protobuf::int32 parentelementindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoWorkingElement* default_instance_;
};
// -------------------------------------------------------------------

class ProtoWorkingData : public ::google::protobuf::Message {
 public:
  ProtoWorkingData();
  virtual ~ProtoWorkingData();

  ProtoWorkingData(const ProtoWorkingData& from);

  inline ProtoWorkingData& operator=(const ProtoWorkingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoWorkingData& default_instance();

  void Swap(ProtoWorkingData* other);

  // implements Message ----------------------------------------------

  ProtoWorkingData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoWorkingData& from);
  void MergeFrom(const ProtoWorkingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 DataId = 1;
  inline bool has_dataid() const;
  inline void clear_dataid();
  static const int kDataIdFieldNumber = 1;
  inline ::google::protobuf::uint32 dataid() const;
  inline void set_dataid(::google::protobuf::uint32 value);

  // optional uint32 Ddi = 2;
  inline bool has_ddi() const;
  inline void clear_ddi();
  static const int kDdiFieldNumber = 2;
  inline ::google::protobuf::uint32 ddi() const;
  inline void set_ddi(::google::protobuf::uint32 value);

  // optional uint32 DomainId = 3;
  inline bool has_domainid() const;
  inline void clear_domainid();
  static const int kDomainIdFieldNumber = 3;
  inline ::google::protobuf::uint32 domainid() const;
  inline void set_domainid(::google::protobuf::uint32 value);

  // optional bool Controllable = 4;
  inline bool has_controllable() const;
  inline void clear_controllable();
  static const int kControllableFieldNumber = 4;
  inline bool controllable() const;
  inline void set_controllable(bool value);

  // optional sint32 Offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional double ScaleFactor = 6;
  inline bool has_scalefactor() const;
  inline void clear_scalefactor();
  static const int kScaleFactorFieldNumber = 6;
  inline double scalefactor() const;
  inline void set_scalefactor(double value);

  // optional string NativeUnitOfMeasure = 7;
  inline bool has_nativeunitofmeasure() const;
  inline void clear_nativeunitofmeasure();
  static const int kNativeUnitOfMeasureFieldNumber = 7;
  inline const ::std::string& nativeunitofmeasure() const;
  inline void set_nativeunitofmeasure(const ::std::string& value);
  inline void set_nativeunitofmeasure(const char* value);
  inline void set_nativeunitofmeasure(const char* value, size_t size);
  inline ::std::string* mutable_nativeunitofmeasure();
  inline ::std::string* release_nativeunitofmeasure();
  inline void set_allocated_nativeunitofmeasure(::std::string* nativeunitofmeasure);

  // @@protoc_insertion_point(class_scope:EqModel.ProtoWorkingData)
 private:
  inline void set_has_dataid();
  inline void clear_has_dataid();
  inline void set_has_ddi();
  inline void clear_has_ddi();
  inline void set_has_domainid();
  inline void clear_has_domainid();
  inline void set_has_controllable();
  inline void clear_has_controllable();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_scalefactor();
  inline void clear_has_scalefactor();
  inline void set_has_nativeunitofmeasure();
  inline void clear_has_nativeunitofmeasure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 dataid_;
  ::google::protobuf::uint32 ddi_;
  ::google::protobuf::uint32 domainid_;
  bool controllable_;
  double scalefactor_;
  ::std::string* nativeunitofmeasure_;
  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoWorkingData* default_instance_;
};
// -------------------------------------------------------------------

class ProtoWorkingState : public ::google::protobuf::Message {
 public:
  ProtoWorkingState();
  virtual ~ProtoWorkingState();

  ProtoWorkingState(const ProtoWorkingState& from);

  inline ProtoWorkingState& operator=(const ProtoWorkingState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoWorkingState& default_instance();

  void Swap(ProtoWorkingState* other);

  // implements Message ----------------------------------------------

  ProtoWorkingState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoWorkingState& from);
  void MergeFrom(const ProtoWorkingState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 Ddi = 2;
  inline bool has_ddi() const;
  inline void clear_ddi();
  static const int kDdiFieldNumber = 2;
  inline ::google::protobuf::uint32 ddi() const;
  inline void set_ddi(::google::protobuf::uint32 value);

  // optional uint32 DomainId = 3;
  inline bool has_domainid() const;
  inline void clear_domainid();
  static const int kDomainIdFieldNumber = 3;
  inline ::google::protobuf::uint32 domainid() const;
  inline void set_domainid(::google::protobuf::uint32 value);

  // optional bool Controllable = 4;
  inline bool has_controllable() const;
  inline void clear_controllable();
  static const int kControllableFieldNumber = 4;
  inline bool controllable() const;
  inline void set_controllable(bool value);

  // optional .EqModel.EViewType ViewType = 5 [default = VT_UNDEFINED];
  inline bool has_viewtype() const;
  inline void clear_viewtype();
  static const int kViewTypeFieldNumber = 5;
  inline ::EqModel::EViewType viewtype() const;
  inline void set_viewtype(::EqModel::EViewType value);

  // optional sint32 ParentIndex = 6;
  inline bool has_parentindex() const;
  inline void clear_parentindex();
  static const int kParentIndexFieldNumber = 6;
  inline ::google::protobuf::int32 parentindex() const;
  inline void set_parentindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EqModel.ProtoWorkingState)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ddi();
  inline void clear_has_ddi();
  inline void set_has_domainid();
  inline void clear_has_domainid();
  inline void set_has_controllable();
  inline void clear_has_controllable();
  inline void set_has_viewtype();
  inline void clear_has_viewtype();
  inline void set_has_parentindex();
  inline void clear_has_parentindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 ddi_;
  ::google::protobuf::uint32 domainid_;
  bool controllable_;
  int viewtype_;
  ::google::protobuf::int32 parentindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoWorkingState* default_instance_;
};
// -------------------------------------------------------------------

class ProtoWorkingFunction : public ::google::protobuf::Message {
 public:
  ProtoWorkingFunction();
  virtual ~ProtoWorkingFunction();

  ProtoWorkingFunction(const ProtoWorkingFunction& from);

  inline ProtoWorkingFunction& operator=(const ProtoWorkingFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoWorkingFunction& default_instance();

  void Swap(ProtoWorkingFunction* other);

  // implements Message ----------------------------------------------

  ProtoWorkingFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoWorkingFunction& from);
  void MergeFrom(const ProtoWorkingFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string Description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional .EqModel.EWorkingFunctionType WorkingFunctionType = 3 [default = WF_UNDEFINED];
  inline bool has_workingfunctiontype() const;
  inline void clear_workingfunctiontype();
  static const int kWorkingFunctionTypeFieldNumber = 3;
  inline ::EqModel::EWorkingFunctionType workingfunctiontype() const;
  inline void set_workingfunctiontype(::EqModel::EWorkingFunctionType value);

  // repeated .EqModel.ProtoRank Ranks = 4;
  inline int ranks_size() const;
  inline void clear_ranks();
  static const int kRanksFieldNumber = 4;
  inline const ::EqModel::ProtoRank& ranks(int index) const;
  inline ::EqModel::ProtoRank* mutable_ranks(int index);
  inline ::EqModel::ProtoRank* add_ranks();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoRank >&
      ranks() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoRank >*
      mutable_ranks();

  // repeated .EqModel.ProtoWorkingElement Elements = 5;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 5;
  inline const ::EqModel::ProtoWorkingElement& elements(int index) const;
  inline ::EqModel::ProtoWorkingElement* mutable_elements(int index);
  inline ::EqModel::ProtoWorkingElement* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingElement >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingElement >*
      mutable_elements();

  // repeated .EqModel.ProtoWorkingData Data = 6;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::EqModel::ProtoWorkingData& data(int index) const;
  inline ::EqModel::ProtoWorkingData* mutable_data(int index);
  inline ::EqModel::ProtoWorkingData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingData >*
      mutable_data();

  // repeated .EqModel.ProtoWorkingState States = 7;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 7;
  inline const ::EqModel::ProtoWorkingState& states(int index) const;
  inline ::EqModel::ProtoWorkingState* mutable_states(int index);
  inline ::EqModel::ProtoWorkingState* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingState >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingState >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:EqModel.ProtoWorkingFunction)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_workingfunctiontype();
  inline void clear_has_workingfunctiontype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoRank > ranks_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingElement > elements_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingData > data_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingState > states_;
  int workingfunctiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoWorkingFunction* default_instance_;
};
// -------------------------------------------------------------------

class ProtoFrame : public ::google::protobuf::Message {
 public:
  ProtoFrame();
  virtual ~ProtoFrame();

  ProtoFrame(const ProtoFrame& from);

  inline ProtoFrame& operator=(const ProtoFrame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoFrame& default_instance();

  void Swap(ProtoFrame* other);

  // implements Message ----------------------------------------------

  ProtoFrame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoFrame& from);
  void MergeFrom(const ProtoFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string Description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string OutOfBoxName = 3;
  inline bool has_outofboxname() const;
  inline void clear_outofboxname();
  static const int kOutOfBoxNameFieldNumber = 3;
  inline const ::std::string& outofboxname() const;
  inline void set_outofboxname(const ::std::string& value);
  inline void set_outofboxname(const char* value);
  inline void set_outofboxname(const char* value, size_t size);
  inline ::std::string* mutable_outofboxname();
  inline ::std::string* release_outofboxname();
  inline void set_allocated_outofboxname(::std::string* outofboxname);

  // optional uint32 ReleaseDate = 4;
  inline bool has_releasedate() const;
  inline void clear_releasedate();
  static const int kReleaseDateFieldNumber = 4;
  inline ::google::protobuf::uint32 releasedate() const;
  inline void set_releasedate(::google::protobuf::uint32 value);

  // optional uint32 LastModifiedDate = 5;
  inline bool has_lastmodifieddate() const;
  inline void clear_lastmodifieddate();
  static const int kLastModifiedDateFieldNumber = 5;
  inline ::google::protobuf::uint32 lastmodifieddate() const;
  inline void set_lastmodifieddate(::google::protobuf::uint32 value);

  // optional .EqModel.EFrameType FrameType = 6 [default = FT_UNDEFINED];
  inline bool has_frametype() const;
  inline void clear_frametype();
  static const int kFrameTypeFieldNumber = 6;
  inline ::EqModel::EFrameType frametype() const;
  inline void set_frametype(::EqModel::EFrameType value);

  // optional .EqModel.EEquipmentType EquipmentType = 7 [default = ET_UNDEFINED];
  inline bool has_equipmenttype() const;
  inline void clear_equipmenttype();
  static const int kEquipmentTypeFieldNumber = 7;
  inline ::EqModel::EEquipmentType equipmenttype() const;
  inline void set_equipmenttype(::EqModel::EEquipmentType value);

  // optional string Comments = 8;
  inline bool has_comments() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 8;
  inline const ::std::string& comments() const;
  inline void set_comments(const ::std::string& value);
  inline void set_comments(const char* value);
  inline void set_comments(const char* value, size_t size);
  inline ::std::string* mutable_comments();
  inline ::std::string* release_comments();
  inline void set_allocated_comments(::std::string* comments);

  // optional uint32 ReceiverID = 9;
  inline bool has_receiverid() const;
  inline void clear_receiverid();
  static const int kReceiverIDFieldNumber = 9;
  inline ::google::protobuf::uint32 receiverid() const;
  inline void set_receiverid(::google::protobuf::uint32 value);

  // optional .EqModel.Offset ReceiverOffset = 10;
  inline bool has_receiveroffset() const;
  inline void clear_receiveroffset();
  static const int kReceiverOffsetFieldNumber = 10;
  inline const ::EqModel::Offset& receiveroffset() const;
  inline ::EqModel::Offset* mutable_receiveroffset();
  inline ::EqModel::Offset* release_receiveroffset();
  inline void set_allocated_receiveroffset(::EqModel::Offset* receiveroffset);

  // optional .EqModel.Offset DropPoint = 11;
  inline bool has_droppoint() const;
  inline void clear_droppoint();
  static const int kDropPointFieldNumber = 11;
  inline const ::EqModel::Offset& droppoint() const;
  inline ::EqModel::Offset* mutable_droppoint();
  inline ::EqModel::Offset* release_droppoint();
  inline void set_allocated_droppoint(::EqModel::Offset* droppoint);

  // optional double FrontOffset = 12;
  inline bool has_frontoffset() const;
  inline void clear_frontoffset();
  static const int kFrontOffsetFieldNumber = 12;
  inline double frontoffset() const;
  inline void set_frontoffset(double value);

  // optional double ImplementLength = 13;
  inline bool has_implementlength() const;
  inline void clear_implementlength();
  static const int kImplementLengthFieldNumber = 13;
  inline double implementlength() const;
  inline void set_implementlength(double value);

  // optional .EqModel.EAxleLocation NonSteeringAxle = 14 [default = AL_UNDEFINED];
  inline bool has_nonsteeringaxle() const;
  inline void clear_nonsteeringaxle();
  static const int kNonSteeringAxleFieldNumber = 14;
  inline ::EqModel::EAxleLocation nonsteeringaxle() const;
  inline void set_nonsteeringaxle(::EqModel::EAxleLocation value);

  // optional double TurnRadius = 15;
  inline bool has_turnradius() const;
  inline void clear_turnradius();
  static const int kTurnRadiusFieldNumber = 15;
  inline double turnradius() const;
  inline void set_turnradius(double value);

  // optional double TurnSensitivity = 16;
  inline bool has_turnsensitivity() const;
  inline void clear_turnsensitivity();
  static const int kTurnSensitivityFieldNumber = 16;
  inline double turnsensitivity() const;
  inline void set_turnsensitivity(double value);

  // optional string SerialNumber = 17;
  inline bool has_serialnumber() const;
  inline void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 17;
  inline const ::std::string& serialnumber() const;
  inline void set_serialnumber(const ::std::string& value);
  inline void set_serialnumber(const char* value);
  inline void set_serialnumber(const char* value, size_t size);
  inline ::std::string* mutable_serialnumber();
  inline ::std::string* release_serialnumber();
  inline void set_allocated_serialnumber(::std::string* serialnumber);

  // optional double PhysicalWidth = 18;
  inline bool has_physicalwidth() const;
  inline void clear_physicalwidth();
  static const int kPhysicalWidthFieldNumber = 18;
  inline double physicalwidth() const;
  inline void set_physicalwidth(double value);

  // optional double PhysicalLength = 19;
  inline bool has_physicallength() const;
  inline void clear_physicallength();
  static const int kPhysicalLengthFieldNumber = 19;
  inline double physicallength() const;
  inline void set_physicallength(double value);

  // optional double ImplementWidth = 20;
  inline bool has_implementwidth() const;
  inline void clear_implementwidth();
  static const int kImplementWidthFieldNumber = 20;
  inline double implementwidth() const;
  inline void set_implementwidth(double value);

  // optional double RowWidth = 21;
  inline bool has_rowwidth() const;
  inline void clear_rowwidth();
  static const int kRowWidthFieldNumber = 21;
  inline double rowwidth() const;
  inline void set_rowwidth(double value);

  // optional uint32 RowCount = 22;
  inline bool has_rowcount() const;
  inline void clear_rowcount();
  static const int kRowCountFieldNumber = 22;
  inline ::google::protobuf::uint32 rowcount() const;
  inline void set_rowcount(::google::protobuf::uint32 value);

  // optional bool InRowConfiguration = 23;
  inline bool has_inrowconfiguration() const;
  inline void clear_inrowconfiguration();
  static const int kInRowConfigurationFieldNumber = 23;
  inline bool inrowconfiguration() const;
  inline void set_inrowconfiguration(bool value);

  // optional double TrackSpacing = 24;
  inline bool has_trackspacing() const;
  inline void clear_trackspacing();
  static const int kTrackSpacingFieldNumber = 24;
  inline double trackspacing() const;
  inline void set_trackspacing(double value);

  // optional double WheelBaseAmount = 25;
  inline bool has_wheelbaseamount() const;
  inline void clear_wheelbaseamount();
  static const int kWheelBaseAmountFieldNumber = 25;
  inline double wheelbaseamount() const;
  inline void set_wheelbaseamount(double value);

  // optional uint32 FrameId = 26;
  inline bool has_frameid() const;
  inline void clear_frameid();
  static const int kFrameIdFieldNumber = 26;
  inline ::google::protobuf::uint32 frameid() const;
  inline void set_frameid(::google::protobuf::uint32 value);

  // optional string ConfigurationGlobalID = 27;
  inline bool has_configurationglobalid() const;
  inline void clear_configurationglobalid();
  static const int kConfigurationGlobalIDFieldNumber = 27;
  inline const ::std::string& configurationglobalid() const;
  inline void set_configurationglobalid(const ::std::string& value);
  inline void set_configurationglobalid(const char* value);
  inline void set_configurationglobalid(const char* value, size_t size);
  inline ::std::string* mutable_configurationglobalid();
  inline ::std::string* release_configurationglobalid();
  inline void set_allocated_configurationglobalid(::std::string* configurationglobalid);

  // optional string Model = 28;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 28;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string GPS = 29;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGPSFieldNumber = 29;
  inline const ::std::string& gps() const;
  inline void set_gps(const ::std::string& value);
  inline void set_gps(const char* value);
  inline void set_gps(const char* value, size_t size);
  inline ::std::string* mutable_gps();
  inline ::std::string* release_gps();
  inline void set_allocated_gps(::std::string* gps);

  // repeated .EqModel.ProtoConnection Connections = 30;
  inline int connections_size() const;
  inline void clear_connections();
  static const int kConnectionsFieldNumber = 30;
  inline const ::EqModel::ProtoConnection& connections(int index) const;
  inline ::EqModel::ProtoConnection* mutable_connections(int index);
  inline ::EqModel::ProtoConnection* add_connections();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnection >&
      connections() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnection >*
      mutable_connections();

  // repeated .EqModel.ProtoWorkingFunction WorkingFunctions = 31;
  inline int workingfunctions_size() const;
  inline void clear_workingfunctions();
  static const int kWorkingFunctionsFieldNumber = 31;
  inline const ::EqModel::ProtoWorkingFunction& workingfunctions(int index) const;
  inline ::EqModel::ProtoWorkingFunction* mutable_workingfunctions(int index);
  inline ::EqModel::ProtoWorkingFunction* add_workingfunctions();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingFunction >&
      workingfunctions() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingFunction >*
      mutable_workingfunctions();

  // @@protoc_insertion_point(class_scope:EqModel.ProtoFrame)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_outofboxname();
  inline void clear_has_outofboxname();
  inline void set_has_releasedate();
  inline void clear_has_releasedate();
  inline void set_has_lastmodifieddate();
  inline void clear_has_lastmodifieddate();
  inline void set_has_frametype();
  inline void clear_has_frametype();
  inline void set_has_equipmenttype();
  inline void clear_has_equipmenttype();
  inline void set_has_comments();
  inline void clear_has_comments();
  inline void set_has_receiverid();
  inline void clear_has_receiverid();
  inline void set_has_receiveroffset();
  inline void clear_has_receiveroffset();
  inline void set_has_droppoint();
  inline void clear_has_droppoint();
  inline void set_has_frontoffset();
  inline void clear_has_frontoffset();
  inline void set_has_implementlength();
  inline void clear_has_implementlength();
  inline void set_has_nonsteeringaxle();
  inline void clear_has_nonsteeringaxle();
  inline void set_has_turnradius();
  inline void clear_has_turnradius();
  inline void set_has_turnsensitivity();
  inline void clear_has_turnsensitivity();
  inline void set_has_serialnumber();
  inline void clear_has_serialnumber();
  inline void set_has_physicalwidth();
  inline void clear_has_physicalwidth();
  inline void set_has_physicallength();
  inline void clear_has_physicallength();
  inline void set_has_implementwidth();
  inline void clear_has_implementwidth();
  inline void set_has_rowwidth();
  inline void clear_has_rowwidth();
  inline void set_has_rowcount();
  inline void clear_has_rowcount();
  inline void set_has_inrowconfiguration();
  inline void clear_has_inrowconfiguration();
  inline void set_has_trackspacing();
  inline void clear_has_trackspacing();
  inline void set_has_wheelbaseamount();
  inline void clear_has_wheelbaseamount();
  inline void set_has_frameid();
  inline void clear_has_frameid();
  inline void set_has_configurationglobalid();
  inline void clear_has_configurationglobalid();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_gps();
  inline void clear_has_gps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* description_;
  ::std::string* outofboxname_;
  ::google::protobuf::uint32 releasedate_;
  ::google::protobuf::uint32 lastmodifieddate_;
  int frametype_;
  int equipmenttype_;
  ::std::string* comments_;
  ::EqModel::Offset* receiveroffset_;
  ::EqModel::Offset* droppoint_;
  ::google::protobuf::uint32 receiverid_;
  int nonsteeringaxle_;
  double frontoffset_;
  double implementlength_;
  double turnradius_;
  double turnsensitivity_;
  ::std::string* serialnumber_;
  double physicalwidth_;
  double physicallength_;
  double implementwidth_;
  double rowwidth_;
  ::google::protobuf::uint32 rowcount_;
  bool inrowconfiguration_;
  double trackspacing_;
  double wheelbaseamount_;
  ::std::string* configurationglobalid_;
  ::std::string* model_;
  ::std::string* gps_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnection > connections_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingFunction > workingfunctions_;
  ::google::protobuf::uint32 frameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoFrame* default_instance_;
};
// -------------------------------------------------------------------

class ProtoEquipmentModel : public ::google::protobuf::Message {
 public:
  ProtoEquipmentModel();
  virtual ~ProtoEquipmentModel();

  ProtoEquipmentModel(const ProtoEquipmentModel& from);

  inline ProtoEquipmentModel& operator=(const ProtoEquipmentModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoEquipmentModel& default_instance();

  void Swap(ProtoEquipmentModel* other);

  // implements Message ----------------------------------------------

  ProtoEquipmentModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoEquipmentModel& from);
  void MergeFrom(const ProtoEquipmentModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional int32 LeadFrameIndex = 2;
  inline bool has_leadframeindex() const;
  inline void clear_leadframeindex();
  static const int kLeadFrameIndexFieldNumber = 2;
  inline ::google::protobuf::int32 leadframeindex() const;
  inline void set_leadframeindex(::google::protobuf::int32 value);

  // repeated .EqModel.ProtoFrame Frames = 3;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 3;
  inline const ::EqModel::ProtoFrame& frames(int index) const;
  inline ::EqModel::ProtoFrame* mutable_frames(int index);
  inline ::EqModel::ProtoFrame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoFrame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoFrame >*
      mutable_frames();

  // repeated .EqModel.ProtoConnectionRelationship ConnectionRelationships = 4;
  inline int connectionrelationships_size() const;
  inline void clear_connectionrelationships();
  static const int kConnectionRelationshipsFieldNumber = 4;
  inline const ::EqModel::ProtoConnectionRelationship& connectionrelationships(int index) const;
  inline ::EqModel::ProtoConnectionRelationship* mutable_connectionrelationships(int index);
  inline ::EqModel::ProtoConnectionRelationship* add_connectionrelationships();
  inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnectionRelationship >&
      connectionrelationships() const;
  inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnectionRelationship >*
      mutable_connectionrelationships();

  // @@protoc_insertion_point(class_scope:EqModel.ProtoEquipmentModel)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_leadframeindex();
  inline void clear_has_leadframeindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoFrame > frames_;
  ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnectionRelationship > connectionrelationships_;
  ::google::protobuf::int32 leadframeindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoEqModel_2eproto();
  friend void protobuf_AssignDesc_ProtoEqModel_2eproto();
  friend void protobuf_ShutdownFile_ProtoEqModel_2eproto();

  void InitAsDefaultInstance();
  static ProtoEquipmentModel* default_instance_;
};
// ===================================================================


// ===================================================================

// Offset

// required double Inline = 1;
inline bool Offset::has_inline_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offset::set_has_inline_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offset::clear_has_inline_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offset::clear_inline_() {
  inline__ = 0;
  clear_has_inline_();
}
inline double Offset::inline_() const {
  return inline__;
}
inline void Offset::set_inline_(double value) {
  set_has_inline_();
  inline__ = value;
}

// optional double Lateral = 2;
inline bool Offset::has_lateral() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offset::set_has_lateral() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offset::clear_has_lateral() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offset::clear_lateral() {
  lateral_ = 0;
  clear_has_lateral();
}
inline double Offset::lateral() const {
  return lateral_;
}
inline void Offset::set_lateral(double value) {
  set_has_lateral();
  lateral_ = value;
}

// optional double Height = 3;
inline bool Offset::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offset::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offset::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offset::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double Offset::height() const {
  return height_;
}
inline void Offset::set_height(double value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// ProtoConnection

// required .EqModel.Offset ConnectionOffset = 1;
inline bool ProtoConnection::has_connectionoffset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoConnection::set_has_connectionoffset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoConnection::clear_has_connectionoffset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoConnection::clear_connectionoffset() {
  if (connectionoffset_ != NULL) connectionoffset_->::EqModel::Offset::Clear();
  clear_has_connectionoffset();
}
inline const ::EqModel::Offset& ProtoConnection::connectionoffset() const {
  return connectionoffset_ != NULL ? *connectionoffset_ : *default_instance_->connectionoffset_;
}
inline ::EqModel::Offset* ProtoConnection::mutable_connectionoffset() {
  set_has_connectionoffset();
  if (connectionoffset_ == NULL) connectionoffset_ = new ::EqModel::Offset;
  return connectionoffset_;
}
inline ::EqModel::Offset* ProtoConnection::release_connectionoffset() {
  clear_has_connectionoffset();
  ::EqModel::Offset* temp = connectionoffset_;
  connectionoffset_ = NULL;
  return temp;
}
inline void ProtoConnection::set_allocated_connectionoffset(::EqModel::Offset* connectionoffset) {
  delete connectionoffset_;
  connectionoffset_ = connectionoffset;
  if (connectionoffset) {
    set_has_connectionoffset();
  } else {
    clear_has_connectionoffset();
  }
}

// optional .EqModel.EConnectionPosition ConnectionPosition = 2 [default = CP_UNDEFINED];
inline bool ProtoConnection::has_connectionposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoConnection::set_has_connectionposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoConnection::clear_has_connectionposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoConnection::clear_connectionposition() {
  connectionposition_ = 0;
  clear_has_connectionposition();
}
inline ::EqModel::EConnectionPosition ProtoConnection::connectionposition() const {
  return static_cast< ::EqModel::EConnectionPosition >(connectionposition_);
}
inline void ProtoConnection::set_connectionposition(::EqModel::EConnectionPosition value) {
  assert(::EqModel::EConnectionPosition_IsValid(value));
  set_has_connectionposition();
  connectionposition_ = value;
}

// optional .EqModel.EHitchType HitchType = 3 [default = HT_UNDEFINED];
inline bool ProtoConnection::has_hitchtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoConnection::set_has_hitchtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoConnection::clear_has_hitchtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoConnection::clear_hitchtype() {
  hitchtype_ = 0;
  clear_has_hitchtype();
}
inline ::EqModel::EHitchType ProtoConnection::hitchtype() const {
  return static_cast< ::EqModel::EHitchType >(hitchtype_);
}
inline void ProtoConnection::set_hitchtype(::EqModel::EHitchType value) {
  assert(::EqModel::EHitchType_IsValid(value));
  set_has_hitchtype();
  hitchtype_ = value;
}

// -------------------------------------------------------------------

// ProtoConnectionRelationship

// required int32 SourceFrameIndex = 1;
inline bool ProtoConnectionRelationship::has_sourceframeindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoConnectionRelationship::set_has_sourceframeindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoConnectionRelationship::clear_has_sourceframeindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoConnectionRelationship::clear_sourceframeindex() {
  sourceframeindex_ = 0;
  clear_has_sourceframeindex();
}
inline ::google::protobuf::int32 ProtoConnectionRelationship::sourceframeindex() const {
  return sourceframeindex_;
}
inline void ProtoConnectionRelationship::set_sourceframeindex(::google::protobuf::int32 value) {
  set_has_sourceframeindex();
  sourceframeindex_ = value;
}

// optional int32 SourceConnectionIndex = 2;
inline bool ProtoConnectionRelationship::has_sourceconnectionindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoConnectionRelationship::set_has_sourceconnectionindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoConnectionRelationship::clear_has_sourceconnectionindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoConnectionRelationship::clear_sourceconnectionindex() {
  sourceconnectionindex_ = 0;
  clear_has_sourceconnectionindex();
}
inline ::google::protobuf::int32 ProtoConnectionRelationship::sourceconnectionindex() const {
  return sourceconnectionindex_;
}
inline void ProtoConnectionRelationship::set_sourceconnectionindex(::google::protobuf::int32 value) {
  set_has_sourceconnectionindex();
  sourceconnectionindex_ = value;
}

// optional int32 TargetFrameIndex = 3;
inline bool ProtoConnectionRelationship::has_targetframeindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoConnectionRelationship::set_has_targetframeindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoConnectionRelationship::clear_has_targetframeindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoConnectionRelationship::clear_targetframeindex() {
  targetframeindex_ = 0;
  clear_has_targetframeindex();
}
inline ::google::protobuf::int32 ProtoConnectionRelationship::targetframeindex() const {
  return targetframeindex_;
}
inline void ProtoConnectionRelationship::set_targetframeindex(::google::protobuf::int32 value) {
  set_has_targetframeindex();
  targetframeindex_ = value;
}

// optional int32 TargetConnectionIndex = 4;
inline bool ProtoConnectionRelationship::has_targetconnectionindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoConnectionRelationship::set_has_targetconnectionindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoConnectionRelationship::clear_has_targetconnectionindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoConnectionRelationship::clear_targetconnectionindex() {
  targetconnectionindex_ = 0;
  clear_has_targetconnectionindex();
}
inline ::google::protobuf::int32 ProtoConnectionRelationship::targetconnectionindex() const {
  return targetconnectionindex_;
}
inline void ProtoConnectionRelationship::set_targetconnectionindex(::google::protobuf::int32 value) {
  set_has_targetconnectionindex();
  targetconnectionindex_ = value;
}

// -------------------------------------------------------------------

// ProtoRank

// required uint32 RankID = 1;
inline bool ProtoRank::has_rankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoRank::set_has_rankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoRank::clear_has_rankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoRank::clear_rankid() {
  rankid_ = 0u;
  clear_has_rankid();
}
inline ::google::protobuf::uint32 ProtoRank::rankid() const {
  return rankid_;
}
inline void ProtoRank::set_rankid(::google::protobuf::uint32 value) {
  set_has_rankid();
  rankid_ = value;
}

// required double Width = 2;
inline bool ProtoRank::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoRank::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoRank::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoRank::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double ProtoRank::width() const {
  return width_;
}
inline void ProtoRank::set_width(double value) {
  set_has_width();
  width_ = value;
}

// optional .EqModel.Offset LocalCenter = 3;
inline bool ProtoRank::has_localcenter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoRank::set_has_localcenter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoRank::clear_has_localcenter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoRank::clear_localcenter() {
  if (localcenter_ != NULL) localcenter_->::EqModel::Offset::Clear();
  clear_has_localcenter();
}
inline const ::EqModel::Offset& ProtoRank::localcenter() const {
  return localcenter_ != NULL ? *localcenter_ : *default_instance_->localcenter_;
}
inline ::EqModel::Offset* ProtoRank::mutable_localcenter() {
  set_has_localcenter();
  if (localcenter_ == NULL) localcenter_ = new ::EqModel::Offset;
  return localcenter_;
}
inline ::EqModel::Offset* ProtoRank::release_localcenter() {
  clear_has_localcenter();
  ::EqModel::Offset* temp = localcenter_;
  localcenter_ = NULL;
  return temp;
}
inline void ProtoRank::set_allocated_localcenter(::EqModel::Offset* localcenter) {
  delete localcenter_;
  localcenter_ = localcenter;
  if (localcenter) {
    set_has_localcenter();
  } else {
    clear_has_localcenter();
  }
}

// repeated sint32 ChildElementIndex = 4;
inline int ProtoRank::childelementindex_size() const {
  return childelementindex_.size();
}
inline void ProtoRank::clear_childelementindex() {
  childelementindex_.Clear();
}
inline ::google::protobuf::int32 ProtoRank::childelementindex(int index) const {
  return childelementindex_.Get(index);
}
inline void ProtoRank::set_childelementindex(int index, ::google::protobuf::int32 value) {
  childelementindex_.Set(index, value);
}
inline void ProtoRank::add_childelementindex(::google::protobuf::int32 value) {
  childelementindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoRank::childelementindex() const {
  return childelementindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoRank::mutable_childelementindex() {
  return &childelementindex_;
}

// -------------------------------------------------------------------

// ProtoWorkingElement

// required double Width = 1;
inline bool ProtoWorkingElement::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoWorkingElement::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoWorkingElement::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoWorkingElement::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double ProtoWorkingElement::width() const {
  return width_;
}
inline void ProtoWorkingElement::set_width(double value) {
  set_has_width();
  width_ = value;
}

// optional .EqModel.Offset CenterOffset = 2;
inline bool ProtoWorkingElement::has_centeroffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoWorkingElement::set_has_centeroffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoWorkingElement::clear_has_centeroffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoWorkingElement::clear_centeroffset() {
  if (centeroffset_ != NULL) centeroffset_->::EqModel::Offset::Clear();
  clear_has_centeroffset();
}
inline const ::EqModel::Offset& ProtoWorkingElement::centeroffset() const {
  return centeroffset_ != NULL ? *centeroffset_ : *default_instance_->centeroffset_;
}
inline ::EqModel::Offset* ProtoWorkingElement::mutable_centeroffset() {
  set_has_centeroffset();
  if (centeroffset_ == NULL) centeroffset_ = new ::EqModel::Offset;
  return centeroffset_;
}
inline ::EqModel::Offset* ProtoWorkingElement::release_centeroffset() {
  clear_has_centeroffset();
  ::EqModel::Offset* temp = centeroffset_;
  centeroffset_ = NULL;
  return temp;
}
inline void ProtoWorkingElement::set_allocated_centeroffset(::EqModel::Offset* centeroffset) {
  delete centeroffset_;
  centeroffset_ = centeroffset;
  if (centeroffset) {
    set_has_centeroffset();
  } else {
    clear_has_centeroffset();
  }
}

// optional uint32 ElementID = 3;
inline bool ProtoWorkingElement::has_elementid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoWorkingElement::set_has_elementid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoWorkingElement::clear_has_elementid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoWorkingElement::clear_elementid() {
  elementid_ = 0u;
  clear_has_elementid();
}
inline ::google::protobuf::uint32 ProtoWorkingElement::elementid() const {
  return elementid_;
}
inline void ProtoWorkingElement::set_elementid(::google::protobuf::uint32 value) {
  set_has_elementid();
  elementid_ = value;
}

// optional .EqModel.EViewType ViewType = 4 [default = VT_UNDEFINED];
inline bool ProtoWorkingElement::has_viewtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoWorkingElement::set_has_viewtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoWorkingElement::clear_has_viewtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoWorkingElement::clear_viewtype() {
  viewtype_ = 0;
  clear_has_viewtype();
}
inline ::EqModel::EViewType ProtoWorkingElement::viewtype() const {
  return static_cast< ::EqModel::EViewType >(viewtype_);
}
inline void ProtoWorkingElement::set_viewtype(::EqModel::EViewType value) {
  assert(::EqModel::EViewType_IsValid(value));
  set_has_viewtype();
  viewtype_ = value;
}

// optional double Left = 5;
inline bool ProtoWorkingElement::has_left() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoWorkingElement::set_has_left() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoWorkingElement::clear_has_left() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoWorkingElement::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline double ProtoWorkingElement::left() const {
  return left_;
}
inline void ProtoWorkingElement::set_left(double value) {
  set_has_left();
  left_ = value;
}

// optional double Right = 6;
inline bool ProtoWorkingElement::has_right() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoWorkingElement::set_has_right() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoWorkingElement::clear_has_right() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoWorkingElement::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline double ProtoWorkingElement::right() const {
  return right_;
}
inline void ProtoWorkingElement::set_right(double value) {
  set_has_right();
  right_ = value;
}

// optional double Size = 7;
inline bool ProtoWorkingElement::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoWorkingElement::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoWorkingElement::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoWorkingElement::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double ProtoWorkingElement::size() const {
  return size_;
}
inline void ProtoWorkingElement::set_size(double value) {
  set_has_size();
  size_ = value;
}

// optional sint32 ParentElementIndex = 8;
inline bool ProtoWorkingElement::has_parentelementindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoWorkingElement::set_has_parentelementindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoWorkingElement::clear_has_parentelementindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoWorkingElement::clear_parentelementindex() {
  parentelementindex_ = 0;
  clear_has_parentelementindex();
}
inline ::google::protobuf::int32 ProtoWorkingElement::parentelementindex() const {
  return parentelementindex_;
}
inline void ProtoWorkingElement::set_parentelementindex(::google::protobuf::int32 value) {
  set_has_parentelementindex();
  parentelementindex_ = value;
}

// repeated sint32 WorkingStateIndex = 9;
inline int ProtoWorkingElement::workingstateindex_size() const {
  return workingstateindex_.size();
}
inline void ProtoWorkingElement::clear_workingstateindex() {
  workingstateindex_.Clear();
}
inline ::google::protobuf::int32 ProtoWorkingElement::workingstateindex(int index) const {
  return workingstateindex_.Get(index);
}
inline void ProtoWorkingElement::set_workingstateindex(int index, ::google::protobuf::int32 value) {
  workingstateindex_.Set(index, value);
}
inline void ProtoWorkingElement::add_workingstateindex(::google::protobuf::int32 value) {
  workingstateindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoWorkingElement::workingstateindex() const {
  return workingstateindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoWorkingElement::mutable_workingstateindex() {
  return &workingstateindex_;
}

// repeated sint32 ChildElementIndex = 10;
inline int ProtoWorkingElement::childelementindex_size() const {
  return childelementindex_.size();
}
inline void ProtoWorkingElement::clear_childelementindex() {
  childelementindex_.Clear();
}
inline ::google::protobuf::int32 ProtoWorkingElement::childelementindex(int index) const {
  return childelementindex_.Get(index);
}
inline void ProtoWorkingElement::set_childelementindex(int index, ::google::protobuf::int32 value) {
  childelementindex_.Set(index, value);
}
inline void ProtoWorkingElement::add_childelementindex(::google::protobuf::int32 value) {
  childelementindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoWorkingElement::childelementindex() const {
  return childelementindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoWorkingElement::mutable_childelementindex() {
  return &childelementindex_;
}

// repeated sint32 WorkingDataIndex = 11;
inline int ProtoWorkingElement::workingdataindex_size() const {
  return workingdataindex_.size();
}
inline void ProtoWorkingElement::clear_workingdataindex() {
  workingdataindex_.Clear();
}
inline ::google::protobuf::int32 ProtoWorkingElement::workingdataindex(int index) const {
  return workingdataindex_.Get(index);
}
inline void ProtoWorkingElement::set_workingdataindex(int index, ::google::protobuf::int32 value) {
  workingdataindex_.Set(index, value);
}
inline void ProtoWorkingElement::add_workingdataindex(::google::protobuf::int32 value) {
  workingdataindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoWorkingElement::workingdataindex() const {
  return workingdataindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoWorkingElement::mutable_workingdataindex() {
  return &workingdataindex_;
}

// -------------------------------------------------------------------

// ProtoWorkingData

// required uint32 DataId = 1;
inline bool ProtoWorkingData::has_dataid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoWorkingData::set_has_dataid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoWorkingData::clear_has_dataid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoWorkingData::clear_dataid() {
  dataid_ = 0u;
  clear_has_dataid();
}
inline ::google::protobuf::uint32 ProtoWorkingData::dataid() const {
  return dataid_;
}
inline void ProtoWorkingData::set_dataid(::google::protobuf::uint32 value) {
  set_has_dataid();
  dataid_ = value;
}

// optional uint32 Ddi = 2;
inline bool ProtoWorkingData::has_ddi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoWorkingData::set_has_ddi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoWorkingData::clear_has_ddi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoWorkingData::clear_ddi() {
  ddi_ = 0u;
  clear_has_ddi();
}
inline ::google::protobuf::uint32 ProtoWorkingData::ddi() const {
  return ddi_;
}
inline void ProtoWorkingData::set_ddi(::google::protobuf::uint32 value) {
  set_has_ddi();
  ddi_ = value;
}

// optional uint32 DomainId = 3;
inline bool ProtoWorkingData::has_domainid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoWorkingData::set_has_domainid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoWorkingData::clear_has_domainid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoWorkingData::clear_domainid() {
  domainid_ = 0u;
  clear_has_domainid();
}
inline ::google::protobuf::uint32 ProtoWorkingData::domainid() const {
  return domainid_;
}
inline void ProtoWorkingData::set_domainid(::google::protobuf::uint32 value) {
  set_has_domainid();
  domainid_ = value;
}

// optional bool Controllable = 4;
inline bool ProtoWorkingData::has_controllable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoWorkingData::set_has_controllable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoWorkingData::clear_has_controllable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoWorkingData::clear_controllable() {
  controllable_ = false;
  clear_has_controllable();
}
inline bool ProtoWorkingData::controllable() const {
  return controllable_;
}
inline void ProtoWorkingData::set_controllable(bool value) {
  set_has_controllable();
  controllable_ = value;
}

// optional sint32 Offset = 5;
inline bool ProtoWorkingData::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoWorkingData::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoWorkingData::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoWorkingData::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 ProtoWorkingData::offset() const {
  return offset_;
}
inline void ProtoWorkingData::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional double ScaleFactor = 6;
inline bool ProtoWorkingData::has_scalefactor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoWorkingData::set_has_scalefactor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoWorkingData::clear_has_scalefactor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoWorkingData::clear_scalefactor() {
  scalefactor_ = 0;
  clear_has_scalefactor();
}
inline double ProtoWorkingData::scalefactor() const {
  return scalefactor_;
}
inline void ProtoWorkingData::set_scalefactor(double value) {
  set_has_scalefactor();
  scalefactor_ = value;
}

// optional string NativeUnitOfMeasure = 7;
inline bool ProtoWorkingData::has_nativeunitofmeasure() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoWorkingData::set_has_nativeunitofmeasure() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoWorkingData::clear_has_nativeunitofmeasure() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoWorkingData::clear_nativeunitofmeasure() {
  if (nativeunitofmeasure_ != &::google::protobuf::internal::kEmptyString) {
    nativeunitofmeasure_->clear();
  }
  clear_has_nativeunitofmeasure();
}
inline const ::std::string& ProtoWorkingData::nativeunitofmeasure() const {
  return *nativeunitofmeasure_;
}
inline void ProtoWorkingData::set_nativeunitofmeasure(const ::std::string& value) {
  set_has_nativeunitofmeasure();
  if (nativeunitofmeasure_ == &::google::protobuf::internal::kEmptyString) {
    nativeunitofmeasure_ = new ::std::string;
  }
  nativeunitofmeasure_->assign(value);
}
inline void ProtoWorkingData::set_nativeunitofmeasure(const char* value) {
  set_has_nativeunitofmeasure();
  if (nativeunitofmeasure_ == &::google::protobuf::internal::kEmptyString) {
    nativeunitofmeasure_ = new ::std::string;
  }
  nativeunitofmeasure_->assign(value);
}
inline void ProtoWorkingData::set_nativeunitofmeasure(const char* value, size_t size) {
  set_has_nativeunitofmeasure();
  if (nativeunitofmeasure_ == &::google::protobuf::internal::kEmptyString) {
    nativeunitofmeasure_ = new ::std::string;
  }
  nativeunitofmeasure_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoWorkingData::mutable_nativeunitofmeasure() {
  set_has_nativeunitofmeasure();
  if (nativeunitofmeasure_ == &::google::protobuf::internal::kEmptyString) {
    nativeunitofmeasure_ = new ::std::string;
  }
  return nativeunitofmeasure_;
}
inline ::std::string* ProtoWorkingData::release_nativeunitofmeasure() {
  clear_has_nativeunitofmeasure();
  if (nativeunitofmeasure_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nativeunitofmeasure_;
    nativeunitofmeasure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoWorkingData::set_allocated_nativeunitofmeasure(::std::string* nativeunitofmeasure) {
  if (nativeunitofmeasure_ != &::google::protobuf::internal::kEmptyString) {
    delete nativeunitofmeasure_;
  }
  if (nativeunitofmeasure) {
    set_has_nativeunitofmeasure();
    nativeunitofmeasure_ = nativeunitofmeasure;
  } else {
    clear_has_nativeunitofmeasure();
    nativeunitofmeasure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProtoWorkingState

// required uint32 Id = 1;
inline bool ProtoWorkingState::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoWorkingState::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoWorkingState::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoWorkingState::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ProtoWorkingState::id() const {
  return id_;
}
inline void ProtoWorkingState::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 Ddi = 2;
inline bool ProtoWorkingState::has_ddi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoWorkingState::set_has_ddi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoWorkingState::clear_has_ddi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoWorkingState::clear_ddi() {
  ddi_ = 0u;
  clear_has_ddi();
}
inline ::google::protobuf::uint32 ProtoWorkingState::ddi() const {
  return ddi_;
}
inline void ProtoWorkingState::set_ddi(::google::protobuf::uint32 value) {
  set_has_ddi();
  ddi_ = value;
}

// optional uint32 DomainId = 3;
inline bool ProtoWorkingState::has_domainid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoWorkingState::set_has_domainid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoWorkingState::clear_has_domainid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoWorkingState::clear_domainid() {
  domainid_ = 0u;
  clear_has_domainid();
}
inline ::google::protobuf::uint32 ProtoWorkingState::domainid() const {
  return domainid_;
}
inline void ProtoWorkingState::set_domainid(::google::protobuf::uint32 value) {
  set_has_domainid();
  domainid_ = value;
}

// optional bool Controllable = 4;
inline bool ProtoWorkingState::has_controllable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoWorkingState::set_has_controllable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoWorkingState::clear_has_controllable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoWorkingState::clear_controllable() {
  controllable_ = false;
  clear_has_controllable();
}
inline bool ProtoWorkingState::controllable() const {
  return controllable_;
}
inline void ProtoWorkingState::set_controllable(bool value) {
  set_has_controllable();
  controllable_ = value;
}

// optional .EqModel.EViewType ViewType = 5 [default = VT_UNDEFINED];
inline bool ProtoWorkingState::has_viewtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoWorkingState::set_has_viewtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoWorkingState::clear_has_viewtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoWorkingState::clear_viewtype() {
  viewtype_ = 0;
  clear_has_viewtype();
}
inline ::EqModel::EViewType ProtoWorkingState::viewtype() const {
  return static_cast< ::EqModel::EViewType >(viewtype_);
}
inline void ProtoWorkingState::set_viewtype(::EqModel::EViewType value) {
  assert(::EqModel::EViewType_IsValid(value));
  set_has_viewtype();
  viewtype_ = value;
}

// optional sint32 ParentIndex = 6;
inline bool ProtoWorkingState::has_parentindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoWorkingState::set_has_parentindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoWorkingState::clear_has_parentindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoWorkingState::clear_parentindex() {
  parentindex_ = 0;
  clear_has_parentindex();
}
inline ::google::protobuf::int32 ProtoWorkingState::parentindex() const {
  return parentindex_;
}
inline void ProtoWorkingState::set_parentindex(::google::protobuf::int32 value) {
  set_has_parentindex();
  parentindex_ = value;
}

// -------------------------------------------------------------------

// ProtoWorkingFunction

// required string Key = 1;
inline bool ProtoWorkingFunction::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoWorkingFunction::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoWorkingFunction::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoWorkingFunction::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ProtoWorkingFunction::key() const {
  return *key_;
}
inline void ProtoWorkingFunction::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProtoWorkingFunction::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProtoWorkingFunction::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoWorkingFunction::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ProtoWorkingFunction::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoWorkingFunction::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Description = 2;
inline bool ProtoWorkingFunction::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoWorkingFunction::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoWorkingFunction::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoWorkingFunction::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ProtoWorkingFunction::description() const {
  return *description_;
}
inline void ProtoWorkingFunction::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ProtoWorkingFunction::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ProtoWorkingFunction::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoWorkingFunction::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ProtoWorkingFunction::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoWorkingFunction::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .EqModel.EWorkingFunctionType WorkingFunctionType = 3 [default = WF_UNDEFINED];
inline bool ProtoWorkingFunction::has_workingfunctiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoWorkingFunction::set_has_workingfunctiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoWorkingFunction::clear_has_workingfunctiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoWorkingFunction::clear_workingfunctiontype() {
  workingfunctiontype_ = 0;
  clear_has_workingfunctiontype();
}
inline ::EqModel::EWorkingFunctionType ProtoWorkingFunction::workingfunctiontype() const {
  return static_cast< ::EqModel::EWorkingFunctionType >(workingfunctiontype_);
}
inline void ProtoWorkingFunction::set_workingfunctiontype(::EqModel::EWorkingFunctionType value) {
  assert(::EqModel::EWorkingFunctionType_IsValid(value));
  set_has_workingfunctiontype();
  workingfunctiontype_ = value;
}

// repeated .EqModel.ProtoRank Ranks = 4;
inline int ProtoWorkingFunction::ranks_size() const {
  return ranks_.size();
}
inline void ProtoWorkingFunction::clear_ranks() {
  ranks_.Clear();
}
inline const ::EqModel::ProtoRank& ProtoWorkingFunction::ranks(int index) const {
  return ranks_.Get(index);
}
inline ::EqModel::ProtoRank* ProtoWorkingFunction::mutable_ranks(int index) {
  return ranks_.Mutable(index);
}
inline ::EqModel::ProtoRank* ProtoWorkingFunction::add_ranks() {
  return ranks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoRank >&
ProtoWorkingFunction::ranks() const {
  return ranks_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoRank >*
ProtoWorkingFunction::mutable_ranks() {
  return &ranks_;
}

// repeated .EqModel.ProtoWorkingElement Elements = 5;
inline int ProtoWorkingFunction::elements_size() const {
  return elements_.size();
}
inline void ProtoWorkingFunction::clear_elements() {
  elements_.Clear();
}
inline const ::EqModel::ProtoWorkingElement& ProtoWorkingFunction::elements(int index) const {
  return elements_.Get(index);
}
inline ::EqModel::ProtoWorkingElement* ProtoWorkingFunction::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::EqModel::ProtoWorkingElement* ProtoWorkingFunction::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingElement >&
ProtoWorkingFunction::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingElement >*
ProtoWorkingFunction::mutable_elements() {
  return &elements_;
}

// repeated .EqModel.ProtoWorkingData Data = 6;
inline int ProtoWorkingFunction::data_size() const {
  return data_.size();
}
inline void ProtoWorkingFunction::clear_data() {
  data_.Clear();
}
inline const ::EqModel::ProtoWorkingData& ProtoWorkingFunction::data(int index) const {
  return data_.Get(index);
}
inline ::EqModel::ProtoWorkingData* ProtoWorkingFunction::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::EqModel::ProtoWorkingData* ProtoWorkingFunction::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingData >&
ProtoWorkingFunction::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingData >*
ProtoWorkingFunction::mutable_data() {
  return &data_;
}

// repeated .EqModel.ProtoWorkingState States = 7;
inline int ProtoWorkingFunction::states_size() const {
  return states_.size();
}
inline void ProtoWorkingFunction::clear_states() {
  states_.Clear();
}
inline const ::EqModel::ProtoWorkingState& ProtoWorkingFunction::states(int index) const {
  return states_.Get(index);
}
inline ::EqModel::ProtoWorkingState* ProtoWorkingFunction::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::EqModel::ProtoWorkingState* ProtoWorkingFunction::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingState >&
ProtoWorkingFunction::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingState >*
ProtoWorkingFunction::mutable_states() {
  return &states_;
}

// -------------------------------------------------------------------

// ProtoFrame

// required string Key = 1;
inline bool ProtoFrame::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoFrame::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoFrame::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoFrame::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ProtoFrame::key() const {
  return *key_;
}
inline void ProtoFrame::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProtoFrame::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProtoFrame::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ProtoFrame::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Description = 2;
inline bool ProtoFrame::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoFrame::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoFrame::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoFrame::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ProtoFrame::description() const {
  return *description_;
}
inline void ProtoFrame::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ProtoFrame::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ProtoFrame::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ProtoFrame::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OutOfBoxName = 3;
inline bool ProtoFrame::has_outofboxname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoFrame::set_has_outofboxname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoFrame::clear_has_outofboxname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoFrame::clear_outofboxname() {
  if (outofboxname_ != &::google::protobuf::internal::kEmptyString) {
    outofboxname_->clear();
  }
  clear_has_outofboxname();
}
inline const ::std::string& ProtoFrame::outofboxname() const {
  return *outofboxname_;
}
inline void ProtoFrame::set_outofboxname(const ::std::string& value) {
  set_has_outofboxname();
  if (outofboxname_ == &::google::protobuf::internal::kEmptyString) {
    outofboxname_ = new ::std::string;
  }
  outofboxname_->assign(value);
}
inline void ProtoFrame::set_outofboxname(const char* value) {
  set_has_outofboxname();
  if (outofboxname_ == &::google::protobuf::internal::kEmptyString) {
    outofboxname_ = new ::std::string;
  }
  outofboxname_->assign(value);
}
inline void ProtoFrame::set_outofboxname(const char* value, size_t size) {
  set_has_outofboxname();
  if (outofboxname_ == &::google::protobuf::internal::kEmptyString) {
    outofboxname_ = new ::std::string;
  }
  outofboxname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_outofboxname() {
  set_has_outofboxname();
  if (outofboxname_ == &::google::protobuf::internal::kEmptyString) {
    outofboxname_ = new ::std::string;
  }
  return outofboxname_;
}
inline ::std::string* ProtoFrame::release_outofboxname() {
  clear_has_outofboxname();
  if (outofboxname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outofboxname_;
    outofboxname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_outofboxname(::std::string* outofboxname) {
  if (outofboxname_ != &::google::protobuf::internal::kEmptyString) {
    delete outofboxname_;
  }
  if (outofboxname) {
    set_has_outofboxname();
    outofboxname_ = outofboxname;
  } else {
    clear_has_outofboxname();
    outofboxname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ReleaseDate = 4;
inline bool ProtoFrame::has_releasedate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoFrame::set_has_releasedate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoFrame::clear_has_releasedate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoFrame::clear_releasedate() {
  releasedate_ = 0u;
  clear_has_releasedate();
}
inline ::google::protobuf::uint32 ProtoFrame::releasedate() const {
  return releasedate_;
}
inline void ProtoFrame::set_releasedate(::google::protobuf::uint32 value) {
  set_has_releasedate();
  releasedate_ = value;
}

// optional uint32 LastModifiedDate = 5;
inline bool ProtoFrame::has_lastmodifieddate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoFrame::set_has_lastmodifieddate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoFrame::clear_has_lastmodifieddate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoFrame::clear_lastmodifieddate() {
  lastmodifieddate_ = 0u;
  clear_has_lastmodifieddate();
}
inline ::google::protobuf::uint32 ProtoFrame::lastmodifieddate() const {
  return lastmodifieddate_;
}
inline void ProtoFrame::set_lastmodifieddate(::google::protobuf::uint32 value) {
  set_has_lastmodifieddate();
  lastmodifieddate_ = value;
}

// optional .EqModel.EFrameType FrameType = 6 [default = FT_UNDEFINED];
inline bool ProtoFrame::has_frametype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoFrame::set_has_frametype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoFrame::clear_has_frametype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoFrame::clear_frametype() {
  frametype_ = 0;
  clear_has_frametype();
}
inline ::EqModel::EFrameType ProtoFrame::frametype() const {
  return static_cast< ::EqModel::EFrameType >(frametype_);
}
inline void ProtoFrame::set_frametype(::EqModel::EFrameType value) {
  assert(::EqModel::EFrameType_IsValid(value));
  set_has_frametype();
  frametype_ = value;
}

// optional .EqModel.EEquipmentType EquipmentType = 7 [default = ET_UNDEFINED];
inline bool ProtoFrame::has_equipmenttype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoFrame::set_has_equipmenttype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoFrame::clear_has_equipmenttype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoFrame::clear_equipmenttype() {
  equipmenttype_ = 0;
  clear_has_equipmenttype();
}
inline ::EqModel::EEquipmentType ProtoFrame::equipmenttype() const {
  return static_cast< ::EqModel::EEquipmentType >(equipmenttype_);
}
inline void ProtoFrame::set_equipmenttype(::EqModel::EEquipmentType value) {
  assert(::EqModel::EEquipmentType_IsValid(value));
  set_has_equipmenttype();
  equipmenttype_ = value;
}

// optional string Comments = 8;
inline bool ProtoFrame::has_comments() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoFrame::set_has_comments() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoFrame::clear_has_comments() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoFrame::clear_comments() {
  if (comments_ != &::google::protobuf::internal::kEmptyString) {
    comments_->clear();
  }
  clear_has_comments();
}
inline const ::std::string& ProtoFrame::comments() const {
  return *comments_;
}
inline void ProtoFrame::set_comments(const ::std::string& value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
}
inline void ProtoFrame::set_comments(const char* value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
}
inline void ProtoFrame::set_comments(const char* value, size_t size) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_comments() {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  return comments_;
}
inline ::std::string* ProtoFrame::release_comments() {
  clear_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comments_;
    comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_comments(::std::string* comments) {
  if (comments_ != &::google::protobuf::internal::kEmptyString) {
    delete comments_;
  }
  if (comments) {
    set_has_comments();
    comments_ = comments;
  } else {
    clear_has_comments();
    comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ReceiverID = 9;
inline bool ProtoFrame::has_receiverid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtoFrame::set_has_receiverid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProtoFrame::clear_has_receiverid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProtoFrame::clear_receiverid() {
  receiverid_ = 0u;
  clear_has_receiverid();
}
inline ::google::protobuf::uint32 ProtoFrame::receiverid() const {
  return receiverid_;
}
inline void ProtoFrame::set_receiverid(::google::protobuf::uint32 value) {
  set_has_receiverid();
  receiverid_ = value;
}

// optional .EqModel.Offset ReceiverOffset = 10;
inline bool ProtoFrame::has_receiveroffset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProtoFrame::set_has_receiveroffset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProtoFrame::clear_has_receiveroffset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProtoFrame::clear_receiveroffset() {
  if (receiveroffset_ != NULL) receiveroffset_->::EqModel::Offset::Clear();
  clear_has_receiveroffset();
}
inline const ::EqModel::Offset& ProtoFrame::receiveroffset() const {
  return receiveroffset_ != NULL ? *receiveroffset_ : *default_instance_->receiveroffset_;
}
inline ::EqModel::Offset* ProtoFrame::mutable_receiveroffset() {
  set_has_receiveroffset();
  if (receiveroffset_ == NULL) receiveroffset_ = new ::EqModel::Offset;
  return receiveroffset_;
}
inline ::EqModel::Offset* ProtoFrame::release_receiveroffset() {
  clear_has_receiveroffset();
  ::EqModel::Offset* temp = receiveroffset_;
  receiveroffset_ = NULL;
  return temp;
}
inline void ProtoFrame::set_allocated_receiveroffset(::EqModel::Offset* receiveroffset) {
  delete receiveroffset_;
  receiveroffset_ = receiveroffset;
  if (receiveroffset) {
    set_has_receiveroffset();
  } else {
    clear_has_receiveroffset();
  }
}

// optional .EqModel.Offset DropPoint = 11;
inline bool ProtoFrame::has_droppoint() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProtoFrame::set_has_droppoint() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProtoFrame::clear_has_droppoint() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProtoFrame::clear_droppoint() {
  if (droppoint_ != NULL) droppoint_->::EqModel::Offset::Clear();
  clear_has_droppoint();
}
inline const ::EqModel::Offset& ProtoFrame::droppoint() const {
  return droppoint_ != NULL ? *droppoint_ : *default_instance_->droppoint_;
}
inline ::EqModel::Offset* ProtoFrame::mutable_droppoint() {
  set_has_droppoint();
  if (droppoint_ == NULL) droppoint_ = new ::EqModel::Offset;
  return droppoint_;
}
inline ::EqModel::Offset* ProtoFrame::release_droppoint() {
  clear_has_droppoint();
  ::EqModel::Offset* temp = droppoint_;
  droppoint_ = NULL;
  return temp;
}
inline void ProtoFrame::set_allocated_droppoint(::EqModel::Offset* droppoint) {
  delete droppoint_;
  droppoint_ = droppoint;
  if (droppoint) {
    set_has_droppoint();
  } else {
    clear_has_droppoint();
  }
}

// optional double FrontOffset = 12;
inline bool ProtoFrame::has_frontoffset() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProtoFrame::set_has_frontoffset() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProtoFrame::clear_has_frontoffset() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProtoFrame::clear_frontoffset() {
  frontoffset_ = 0;
  clear_has_frontoffset();
}
inline double ProtoFrame::frontoffset() const {
  return frontoffset_;
}
inline void ProtoFrame::set_frontoffset(double value) {
  set_has_frontoffset();
  frontoffset_ = value;
}

// optional double ImplementLength = 13;
inline bool ProtoFrame::has_implementlength() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProtoFrame::set_has_implementlength() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProtoFrame::clear_has_implementlength() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProtoFrame::clear_implementlength() {
  implementlength_ = 0;
  clear_has_implementlength();
}
inline double ProtoFrame::implementlength() const {
  return implementlength_;
}
inline void ProtoFrame::set_implementlength(double value) {
  set_has_implementlength();
  implementlength_ = value;
}

// optional .EqModel.EAxleLocation NonSteeringAxle = 14 [default = AL_UNDEFINED];
inline bool ProtoFrame::has_nonsteeringaxle() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProtoFrame::set_has_nonsteeringaxle() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProtoFrame::clear_has_nonsteeringaxle() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProtoFrame::clear_nonsteeringaxle() {
  nonsteeringaxle_ = 0;
  clear_has_nonsteeringaxle();
}
inline ::EqModel::EAxleLocation ProtoFrame::nonsteeringaxle() const {
  return static_cast< ::EqModel::EAxleLocation >(nonsteeringaxle_);
}
inline void ProtoFrame::set_nonsteeringaxle(::EqModel::EAxleLocation value) {
  assert(::EqModel::EAxleLocation_IsValid(value));
  set_has_nonsteeringaxle();
  nonsteeringaxle_ = value;
}

// optional double TurnRadius = 15;
inline bool ProtoFrame::has_turnradius() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ProtoFrame::set_has_turnradius() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ProtoFrame::clear_has_turnradius() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ProtoFrame::clear_turnradius() {
  turnradius_ = 0;
  clear_has_turnradius();
}
inline double ProtoFrame::turnradius() const {
  return turnradius_;
}
inline void ProtoFrame::set_turnradius(double value) {
  set_has_turnradius();
  turnradius_ = value;
}

// optional double TurnSensitivity = 16;
inline bool ProtoFrame::has_turnsensitivity() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ProtoFrame::set_has_turnsensitivity() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ProtoFrame::clear_has_turnsensitivity() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ProtoFrame::clear_turnsensitivity() {
  turnsensitivity_ = 0;
  clear_has_turnsensitivity();
}
inline double ProtoFrame::turnsensitivity() const {
  return turnsensitivity_;
}
inline void ProtoFrame::set_turnsensitivity(double value) {
  set_has_turnsensitivity();
  turnsensitivity_ = value;
}

// optional string SerialNumber = 17;
inline bool ProtoFrame::has_serialnumber() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ProtoFrame::set_has_serialnumber() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ProtoFrame::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ProtoFrame::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& ProtoFrame::serialnumber() const {
  return *serialnumber_;
}
inline void ProtoFrame::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void ProtoFrame::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void ProtoFrame::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* ProtoFrame::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_serialnumber(::std::string* serialnumber) {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete serialnumber_;
  }
  if (serialnumber) {
    set_has_serialnumber();
    serialnumber_ = serialnumber;
  } else {
    clear_has_serialnumber();
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double PhysicalWidth = 18;
inline bool ProtoFrame::has_physicalwidth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ProtoFrame::set_has_physicalwidth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ProtoFrame::clear_has_physicalwidth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ProtoFrame::clear_physicalwidth() {
  physicalwidth_ = 0;
  clear_has_physicalwidth();
}
inline double ProtoFrame::physicalwidth() const {
  return physicalwidth_;
}
inline void ProtoFrame::set_physicalwidth(double value) {
  set_has_physicalwidth();
  physicalwidth_ = value;
}

// optional double PhysicalLength = 19;
inline bool ProtoFrame::has_physicallength() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ProtoFrame::set_has_physicallength() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ProtoFrame::clear_has_physicallength() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ProtoFrame::clear_physicallength() {
  physicallength_ = 0;
  clear_has_physicallength();
}
inline double ProtoFrame::physicallength() const {
  return physicallength_;
}
inline void ProtoFrame::set_physicallength(double value) {
  set_has_physicallength();
  physicallength_ = value;
}

// optional double ImplementWidth = 20;
inline bool ProtoFrame::has_implementwidth() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ProtoFrame::set_has_implementwidth() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ProtoFrame::clear_has_implementwidth() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ProtoFrame::clear_implementwidth() {
  implementwidth_ = 0;
  clear_has_implementwidth();
}
inline double ProtoFrame::implementwidth() const {
  return implementwidth_;
}
inline void ProtoFrame::set_implementwidth(double value) {
  set_has_implementwidth();
  implementwidth_ = value;
}

// optional double RowWidth = 21;
inline bool ProtoFrame::has_rowwidth() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ProtoFrame::set_has_rowwidth() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ProtoFrame::clear_has_rowwidth() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ProtoFrame::clear_rowwidth() {
  rowwidth_ = 0;
  clear_has_rowwidth();
}
inline double ProtoFrame::rowwidth() const {
  return rowwidth_;
}
inline void ProtoFrame::set_rowwidth(double value) {
  set_has_rowwidth();
  rowwidth_ = value;
}

// optional uint32 RowCount = 22;
inline bool ProtoFrame::has_rowcount() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ProtoFrame::set_has_rowcount() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ProtoFrame::clear_has_rowcount() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ProtoFrame::clear_rowcount() {
  rowcount_ = 0u;
  clear_has_rowcount();
}
inline ::google::protobuf::uint32 ProtoFrame::rowcount() const {
  return rowcount_;
}
inline void ProtoFrame::set_rowcount(::google::protobuf::uint32 value) {
  set_has_rowcount();
  rowcount_ = value;
}

// optional bool InRowConfiguration = 23;
inline bool ProtoFrame::has_inrowconfiguration() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ProtoFrame::set_has_inrowconfiguration() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ProtoFrame::clear_has_inrowconfiguration() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ProtoFrame::clear_inrowconfiguration() {
  inrowconfiguration_ = false;
  clear_has_inrowconfiguration();
}
inline bool ProtoFrame::inrowconfiguration() const {
  return inrowconfiguration_;
}
inline void ProtoFrame::set_inrowconfiguration(bool value) {
  set_has_inrowconfiguration();
  inrowconfiguration_ = value;
}

// optional double TrackSpacing = 24;
inline bool ProtoFrame::has_trackspacing() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ProtoFrame::set_has_trackspacing() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ProtoFrame::clear_has_trackspacing() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ProtoFrame::clear_trackspacing() {
  trackspacing_ = 0;
  clear_has_trackspacing();
}
inline double ProtoFrame::trackspacing() const {
  return trackspacing_;
}
inline void ProtoFrame::set_trackspacing(double value) {
  set_has_trackspacing();
  trackspacing_ = value;
}

// optional double WheelBaseAmount = 25;
inline bool ProtoFrame::has_wheelbaseamount() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ProtoFrame::set_has_wheelbaseamount() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ProtoFrame::clear_has_wheelbaseamount() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ProtoFrame::clear_wheelbaseamount() {
  wheelbaseamount_ = 0;
  clear_has_wheelbaseamount();
}
inline double ProtoFrame::wheelbaseamount() const {
  return wheelbaseamount_;
}
inline void ProtoFrame::set_wheelbaseamount(double value) {
  set_has_wheelbaseamount();
  wheelbaseamount_ = value;
}

// optional uint32 FrameId = 26;
inline bool ProtoFrame::has_frameid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ProtoFrame::set_has_frameid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ProtoFrame::clear_has_frameid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ProtoFrame::clear_frameid() {
  frameid_ = 0u;
  clear_has_frameid();
}
inline ::google::protobuf::uint32 ProtoFrame::frameid() const {
  return frameid_;
}
inline void ProtoFrame::set_frameid(::google::protobuf::uint32 value) {
  set_has_frameid();
  frameid_ = value;
}

// optional string ConfigurationGlobalID = 27;
inline bool ProtoFrame::has_configurationglobalid() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ProtoFrame::set_has_configurationglobalid() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ProtoFrame::clear_has_configurationglobalid() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ProtoFrame::clear_configurationglobalid() {
  if (configurationglobalid_ != &::google::protobuf::internal::kEmptyString) {
    configurationglobalid_->clear();
  }
  clear_has_configurationglobalid();
}
inline const ::std::string& ProtoFrame::configurationglobalid() const {
  return *configurationglobalid_;
}
inline void ProtoFrame::set_configurationglobalid(const ::std::string& value) {
  set_has_configurationglobalid();
  if (configurationglobalid_ == &::google::protobuf::internal::kEmptyString) {
    configurationglobalid_ = new ::std::string;
  }
  configurationglobalid_->assign(value);
}
inline void ProtoFrame::set_configurationglobalid(const char* value) {
  set_has_configurationglobalid();
  if (configurationglobalid_ == &::google::protobuf::internal::kEmptyString) {
    configurationglobalid_ = new ::std::string;
  }
  configurationglobalid_->assign(value);
}
inline void ProtoFrame::set_configurationglobalid(const char* value, size_t size) {
  set_has_configurationglobalid();
  if (configurationglobalid_ == &::google::protobuf::internal::kEmptyString) {
    configurationglobalid_ = new ::std::string;
  }
  configurationglobalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_configurationglobalid() {
  set_has_configurationglobalid();
  if (configurationglobalid_ == &::google::protobuf::internal::kEmptyString) {
    configurationglobalid_ = new ::std::string;
  }
  return configurationglobalid_;
}
inline ::std::string* ProtoFrame::release_configurationglobalid() {
  clear_has_configurationglobalid();
  if (configurationglobalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configurationglobalid_;
    configurationglobalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_configurationglobalid(::std::string* configurationglobalid) {
  if (configurationglobalid_ != &::google::protobuf::internal::kEmptyString) {
    delete configurationglobalid_;
  }
  if (configurationglobalid) {
    set_has_configurationglobalid();
    configurationglobalid_ = configurationglobalid;
  } else {
    clear_has_configurationglobalid();
    configurationglobalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Model = 28;
inline bool ProtoFrame::has_model() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ProtoFrame::set_has_model() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ProtoFrame::clear_has_model() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ProtoFrame::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& ProtoFrame::model() const {
  return *model_;
}
inline void ProtoFrame::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void ProtoFrame::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void ProtoFrame::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* ProtoFrame::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GPS = 29;
inline bool ProtoFrame::has_gps() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ProtoFrame::set_has_gps() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ProtoFrame::clear_has_gps() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ProtoFrame::clear_gps() {
  if (gps_ != &::google::protobuf::internal::kEmptyString) {
    gps_->clear();
  }
  clear_has_gps();
}
inline const ::std::string& ProtoFrame::gps() const {
  return *gps_;
}
inline void ProtoFrame::set_gps(const ::std::string& value) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  gps_->assign(value);
}
inline void ProtoFrame::set_gps(const char* value) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  gps_->assign(value);
}
inline void ProtoFrame::set_gps(const char* value, size_t size) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  gps_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoFrame::mutable_gps() {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    gps_ = new ::std::string;
  }
  return gps_;
}
inline ::std::string* ProtoFrame::release_gps() {
  clear_has_gps();
  if (gps_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gps_;
    gps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoFrame::set_allocated_gps(::std::string* gps) {
  if (gps_ != &::google::protobuf::internal::kEmptyString) {
    delete gps_;
  }
  if (gps) {
    set_has_gps();
    gps_ = gps;
  } else {
    clear_has_gps();
    gps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .EqModel.ProtoConnection Connections = 30;
inline int ProtoFrame::connections_size() const {
  return connections_.size();
}
inline void ProtoFrame::clear_connections() {
  connections_.Clear();
}
inline const ::EqModel::ProtoConnection& ProtoFrame::connections(int index) const {
  return connections_.Get(index);
}
inline ::EqModel::ProtoConnection* ProtoFrame::mutable_connections(int index) {
  return connections_.Mutable(index);
}
inline ::EqModel::ProtoConnection* ProtoFrame::add_connections() {
  return connections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnection >&
ProtoFrame::connections() const {
  return connections_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnection >*
ProtoFrame::mutable_connections() {
  return &connections_;
}

// repeated .EqModel.ProtoWorkingFunction WorkingFunctions = 31;
inline int ProtoFrame::workingfunctions_size() const {
  return workingfunctions_.size();
}
inline void ProtoFrame::clear_workingfunctions() {
  workingfunctions_.Clear();
}
inline const ::EqModel::ProtoWorkingFunction& ProtoFrame::workingfunctions(int index) const {
  return workingfunctions_.Get(index);
}
inline ::EqModel::ProtoWorkingFunction* ProtoFrame::mutable_workingfunctions(int index) {
  return workingfunctions_.Mutable(index);
}
inline ::EqModel::ProtoWorkingFunction* ProtoFrame::add_workingfunctions() {
  return workingfunctions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingFunction >&
ProtoFrame::workingfunctions() const {
  return workingfunctions_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoWorkingFunction >*
ProtoFrame::mutable_workingfunctions() {
  return &workingfunctions_;
}

// -------------------------------------------------------------------

// ProtoEquipmentModel

// required string Key = 1;
inline bool ProtoEquipmentModel::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoEquipmentModel::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoEquipmentModel::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoEquipmentModel::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ProtoEquipmentModel::key() const {
  return *key_;
}
inline void ProtoEquipmentModel::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProtoEquipmentModel::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProtoEquipmentModel::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoEquipmentModel::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ProtoEquipmentModel::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoEquipmentModel::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 LeadFrameIndex = 2;
inline bool ProtoEquipmentModel::has_leadframeindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoEquipmentModel::set_has_leadframeindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoEquipmentModel::clear_has_leadframeindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoEquipmentModel::clear_leadframeindex() {
  leadframeindex_ = 0;
  clear_has_leadframeindex();
}
inline ::google::protobuf::int32 ProtoEquipmentModel::leadframeindex() const {
  return leadframeindex_;
}
inline void ProtoEquipmentModel::set_leadframeindex(::google::protobuf::int32 value) {
  set_has_leadframeindex();
  leadframeindex_ = value;
}

// repeated .EqModel.ProtoFrame Frames = 3;
inline int ProtoEquipmentModel::frames_size() const {
  return frames_.size();
}
inline void ProtoEquipmentModel::clear_frames() {
  frames_.Clear();
}
inline const ::EqModel::ProtoFrame& ProtoEquipmentModel::frames(int index) const {
  return frames_.Get(index);
}
inline ::EqModel::ProtoFrame* ProtoEquipmentModel::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::EqModel::ProtoFrame* ProtoEquipmentModel::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoFrame >&
ProtoEquipmentModel::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoFrame >*
ProtoEquipmentModel::mutable_frames() {
  return &frames_;
}

// repeated .EqModel.ProtoConnectionRelationship ConnectionRelationships = 4;
inline int ProtoEquipmentModel::connectionrelationships_size() const {
  return connectionrelationships_.size();
}
inline void ProtoEquipmentModel::clear_connectionrelationships() {
  connectionrelationships_.Clear();
}
inline const ::EqModel::ProtoConnectionRelationship& ProtoEquipmentModel::connectionrelationships(int index) const {
  return connectionrelationships_.Get(index);
}
inline ::EqModel::ProtoConnectionRelationship* ProtoEquipmentModel::mutable_connectionrelationships(int index) {
  return connectionrelationships_.Mutable(index);
}
inline ::EqModel::ProtoConnectionRelationship* ProtoEquipmentModel::add_connectionrelationships() {
  return connectionrelationships_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnectionRelationship >&
ProtoEquipmentModel::connectionrelationships() const {
  return connectionrelationships_;
}
inline ::google::protobuf::RepeatedPtrField< ::EqModel::ProtoConnectionRelationship >*
ProtoEquipmentModel::mutable_connectionrelationships() {
  return &connectionrelationships_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace EqModel

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::EFrameType>() {
  return ::EqModel::EFrameType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::EWorkingFunctionType>() {
  return ::EqModel::EWorkingFunctionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::EViewType>() {
  return ::EqModel::EViewType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::EAxleLocation>() {
  return ::EqModel::EAxleLocation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::EEquipmentType>() {
  return ::EqModel::EEquipmentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::ERecordingSource>() {
  return ::EqModel::ERecordingSource_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::EConnectionPosition>() {
  return ::EqModel::EConnectionPosition_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EqModel::EHitchType>() {
  return ::EqModel::EHitchType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoEqModel_2eproto__INCLUDED
